/***********************************************************************
 * XG SERVER
 * core/event.h
 * Механизм обработки событий
 * 
 * Copyright (с) 2014-2015 Stanislav V. Tretyakov, svtrostov@yandex.ru
 **********************************************************************/   

/*
 * Как это работает:
 * В момент старта приложения выполняется регистрация нового события
 * Новому событию автоматически присваивается уникальный идентификатор,
 * который впоследствии используется для обработки этого события
 * 		int new_event_id = eventRegister();
 * 
 * После регистрации события, добавляются функции-обработчики, которые 
 * выполняют какую-либо работу (например, обработку данных) в момент
 * наступления события.
 * Прототип функции-обработчика выглядит следующим образом:
 * 		void my_function(evinfo_s * event){}
 * Функция-обработчик напрямую не возвращает никакого результата,
 * все возможные результаты и изменения вносятся в поля структуры evinfo_s
 * При вызове функции-обработчика, в нее передается указатель на структуру
 * evinfo_s, содержащую данные для функции и дополнительную информацию
 * 		event->event_id	-	Идентификатор события, в рамках которого была вызвана функция (только для чтения)
 * 		event->self		-	Указатель на вызываемую функцию-обработчик (т.е. указатель на саму функцию, в которой идет обработка события в настоящий момент)
 * 		event->data		-	Указатель на произвольные данные, которые участвуют в процессе обработки
 * 		event->args		-	Дополнительные аргументы, переданные при генерации события помимо произвольных данных event->data
 * 		event->priority	- 	Приоритет вызываемой функции-обработчика, установленных при регистрации этой функции в качестве функции-обработчика (только для чтения)
 * 		event->index	-	Индекс функции-обработчика в очереди вызова (какой по счету вызвана функция-обработчик при обработке события) (только для чтения)
 * 		event->count	-	Общее количество функций-обработчиков для данного события (только для чтения)
 * 		event->result	-	Результат обработки события, который будет возвращен как результат выхова fireEvent()
 * 							Результат задается функциями-обработчиками данного события.
 * 							Поскольку результат один, а функций-обработчиков может быть несколько, контроль за значением event->result возлагается на функции-обработчики
 * 							По-умолчанию event->result = 0
 * 		event->stop			Признак, указывающий необходимость прервать вызов других функций-обработчиков по завершении выполняемой функции
 * 							Задается функциями-обработчиками данного события, по-умолчанию event->stop = false;
 * 		event->again		Признак, указывающий необходимость вызвать эту же функцию-обработчик снова сразу же по завершении выполняемой функции
 * 							При каждом вызове функции-обработчика event->again устанавливается в значение false
 * 		event->calls		Количество вызовов данной функции-обработчика (т.е. какое количество раз эта функция-обработчик вызывается, применяется при использовании again), 
 * 							при первом вызове функции-обработчика event->calls = 1 (только для чтения)
 * Регистрация функции-обработчика выполняется функцией addListener(new_event_id, my_function, ignore_if_exists, priority)
 * где: 
 * 		new_event_id - идентификатор события, полученный в результате вызова eventRegister()
 * 		my_function - указатель на функцию-обработчик
 * 		ignore_if_exists - признак, указывающий что необходимо игнорировать вставку функции-обработчика, если она уже присутствует в событии
 * 		priority - приоритет вызова функции при наступлении события (чем выше значение - тем выше в очереди - тем первее вызывается) 
 * Пример: 
 * 		addListener(new_event_id, my_function, true, 5);
 * 
 * Генерация события осуществляется посредством вызова функции fireEvent(event_id, data, ...)
 * где:
 * 		event_id - идентификатор события
 * 		data - произвольные данные, передаваемые в функции-обработчики данного события (event->data)
 * 		... - дополнительные аргументы, передаваемые в функции-обработчики (event->args, представляет собой va_list)
 * После вызова всех функций-обработчиков fireEvent() возвращает числовой результат обработки, указанный в event->result 
 * Пример:
 * 		int result = fireEvent(new_event_id, "test event message: %s\n", "bla bla bla");
 * 
 */

#ifndef _XGEVENT_H
#define _XGEVENT_H

#ifdef __cplusplus
extern "C" {
#endif


/***********************************************************************
 * Подключаемые заголовки
 **********************************************************************/
#include <stdbool.h>	//true false
#include <stdint.h>		//uint32_t
#include <stdlib.h>


/***********************************************************************
 * Предустановленные события ядра (с ID от 0 до 99)
 **********************************************************************/

/*
 * События в момент запуска приложения
 */
 
//Событие функции main() перед началом выполнения каких либо действий
#define EVENT_LOADER_START			1

//Событие функции main() после обработки конфигурационных файлов, 
//инициализации сессий, механизмов работы с базами данных, маршрутов, алиасов и т.д.
//и до момента непосредственного старта сервера
#define EVENT_LOADER_COMPLETE		2


//Событие возникает перед началом запуска сервера
//В качестве аргумента передается указатель на структуру server_s
#define EVENT_SERVER_INIT			3


//Событие возникает после инициализации прослушивающего сокета, рабочих потов и т.д.
//и перед непосредственным началом приема соединений
//В качестве аргумента передается указатель на структуру server_s
#define EVENT_SERVER_START			4


//Событие возникает сразу после завершения приема клиентских соединений перед завершением работы сервера
//В качестве аргумента передается указатель на структуру server_s
#define EVENT_SERVER_STOP			5









/***********************************************************************
 * Объявления и декларации
 **********************************************************************/





/***********************************************************************
 * Структуры
 **********************************************************************/
typedef struct	type_listener_s		listener_s;	//Структура функции-обработчика события
typedef struct	type_event_s		event_s;	//Структура события
typedef struct	type_evinfo_s		evinfo_s;	//Структура информации о событии для функций-обработчиков

/*
 * Прототип функции-обработчика, отвечающий за обработку события
 * uint32_t - идентификатор события
 * void * - указатель на данные для функции-обрабочика
 * В результате работы функция-обработчик может вернуть какие-то данные
 */
typedef void (*listener_cb)(evinfo_s *);



/*
 * Структура функции-обработчика события
 */
typedef struct type_listener_s{
	event_s			* event;		//Указатель на событие, для которого вызывается указанная функция-обработчик
	listener_s		* prev;			//Предыдущая функция-обработчик
	listener_s		* next;			//Следующая функция-обработчик
	listener_cb		listener;		//Функция-обработчик
	int				priority;		//Приоритет вызова функции (чем выше значение - тем выше в очереди - тем первее вызывается)
} listener_s;


/*
 * Структура события
 */
typedef struct type_event_s{
	uint32_t		event_id;		//Идентификатор события
	listener_s		* first;		//Список функций-обработчиков событий - первый элемент
	listener_s		* last;			//Список функций-обработчиков событий - последний элемент
	uint32_t		count;			//Количество функций-обработчиков для данного события
} event_s;


/*
 * Структура информации о событии для функций-обработчиков
 */
typedef struct type_evinfo_s{
	uint32_t		event_id;		//Идентификатор события
	listener_cb		self;			//Указатель на вызываемую функцию-обработчик (на самого себя)
	void			* data;			//Данные пользователя
	va_list			args;			//Дополнительные аргументы, переданные в функцию
	int				result;			//Результат отработки события
	int				priority;		//Приоритет, заданный для вызываемой функции-обработчика
	uint32_t		index;			//Индекс функции-обработчика в очереди вызова
	uint32_t		count;			//Общее количество функций-обработчиков для данного события
	uint32_t		calls;			//Количество вызовов данной функции-обработчика (т.е. какое количество раз эта функция-обработчик вызывается, применяется при использовании again)
	bool			again;			//Признак, указывающий необходимость вызвать эту же функцию-обработчик снова сразу же по завершении выполняемой функции
	bool			stop;			//Признак, указывающий необходимость прервать вызов других функций-обработчиков по завершении выполняемой функции
} evinfo_s;







/***********************************************************************
 * Функции
 **********************************************************************/
void			eventInit(void);	//Инициализация механизма событий
void			eventFree(void);	//Освобождение памяти, занятой под событие и его обработчики
void			eventCoreRegister(uint32_t event_id);	//Регистрирует системное событие ядра под определенным идентификатором
uint32_t		eventRegister(void);	//Регистрирует событие и возвращает идентификатор события
uint32_t		addListener(uint32_t event_id, listener_cb f, bool ignore_if_exists, int priority);	//Добавляет функцию-обработчик для указанного события
uint32_t		removeListener(uint32_t event_id, listener_cb f, uint32_t count);		//Удаляет функцию-обработчик для указанного события
uint32_t		eventClear(uint32_t event_id);	//Удаляет все функции-обработчики для данного события
int				fireEvent(uint32_t event_id, void * data, ...);	//Вызывает функции-обработчики для указанного события с передачей в них в качестве аргумента указателя data


#ifdef __cplusplus
}
#endif

#endif //_XGEVENT_H
